//@version=4
strategy("Tangram Bot 2", "Parametros TANGRAM", true, pyramiding=0, calc_on_order_fills=false, calc_on_every_tick=true, backtest_fill_limits_assumption=5, default_qty_value=1, linktoseries=false, slippage=2, commission_type=strategy.commission.cash_per_contract, commission_value=5)
// === GENERAL INPUTS ===


// Indicadores Tecnicos
iOPModo      = input(3, "[Estrategia] Sentido das operacoes: 0:Off 1:Comprado, 2:Vendido, 3:Ambos sem Reversao, 4:Ambos com Reversao", minval=0, maxval=4, step=1)
//iPrevinir    = input(true, "[Estrategia] Prevenir entradas no mesmo sentido apos uma saida")
iPrevinir    = input("Nao",  "[Estrategia] Habilitar bloqueio de nova entrada no mesmo dia apos uma saida", options=["Sim","Nao"])=="Sim"

dummyMM= input(false, "[Medias Moveis]-------------------------------------------------------------", type = input.bool )
iMMModo      = input(3,                                   "[MM] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iMMInv       = input("Nao",                               "[MM] Inverter", options=["Sim", "Nao"]) =="Sim"
iMMForma     = input("Media curta acima/abaixo da longa", "[MM] Forma de uso", options=["Cruzamento das Medias", "Media curta acima/abaixo da longa"])
iMMCurtaTipo = input("Exponencial",                       "[MM] Media Curta: Tipo", options=["Simples", "Exponencial"] )
iMMCurtaLen  = input(5,                                   "[MM] Media curta: Numero de periodos", minval=1)
iMMCurtaDes  = input(0,                                   "[MM] Media Curta: Deslocamento", minval=0)
iMMCurtaSrc  = input(close,                               "[MM] Media Curta: Fonte")
iMMLongaTipo = input("Simples",                           "[MM] Media Longa: Tipo", options=["Simples", "Exponencial"])
iMMLongaLen  = input(40,                                  "[MM] Media longa: Numero de periodos", minval=1)
iMMLongaDes  = input(0,                                   "[MM] Media Longa: Deslocamento", minval=0)
iMMLongaSrc  = input(close,                               "[MM] Media Longa: Fonte")
iMMPlot      = input("Sim",                               "[MM] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"



dummyHilo= input(false, "[HiLo Activator]----------------------------------------------------------", type = input.bool )
iHLModo  = input(3,                                      "[HiLo] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iHLInv   = input("Nao",                                  "[HiLo] Inverter" , options=["Sim", "Nao"]) =="Sim"
iHLForma = input("Sentido da escada do HiLo",            "[HiLo] Modo de Operacao", options=["Mudanca no sentido da escada do HiLo", "Sentido da escada do HiLo"])
iHLLen   = input(11,                                      "[HiLo] Numero de periodos", minval=1, step=5)
iHLPlot  = input("Sim",                                  "[HiLo] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyMACD= input(false, "[MACD]-------------------------------------------------------------------", type = input.bool )
iMACDModo   = input(0,                                               "[MACD] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iMACDInv    = input("Nao",                                           "[MACD] Inverter" , options=["Sim", "Nao"]) =="Sim"
iMACDForma  = input("Cruzamento da linha MACD com a linha de sinal", "[MACD] Modo de Operacao", options=["Cruzamento da linha MACD com a linha de sinal", "Linha MACD acima/abaixo da linha de sinal"])
iMACDSrc    = input(close,                                           "[MACD] Valor usado")
iMACDTipo   = input("Simples",                                       "[MACD] Tipo de media", options=["Simples"])
iMACDCurta  = input(12,                                              "[MACD] Media curta: Numero de periodos", minval=1)
iMACDLonga  = input(26,                                              "[MACD] Media longa: Numero de periodos", minval=2)
iMACDSinal  = input(9,                                               "[MACD] Linha de sinal: Numero de periodos", minval=1)
iMACDFiltro = input(false,                                           "[MACD] Usar filtro para validar MACD")
iMACDFilVal = input(0.0,                                             "[MACD] Filtro para comprar/vender apenas com MACD abaixo/acima do valor do filtro", minval=0)
iMACDPlot   = input("Nao",                                           "[MACD] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyADX= input(false, "[ADX - DI+/DI-]------------------------------------------------------------", type = input.bool )
iADXModo  = input(0,                             "[ADX] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iADXInv   = input("Nao",                         "[ADX] Inverter", options=["Sim", "Nao"]) =="Sim"
iADXForma = input("Cruzamento do DI+ com o DI-", "[ADX] Forma de uso", options=["Cruzamento do DI+ com o DI-", "DI+ acima/abaixo do DI-"])
iADXLen   = input(14,                            "[ADX] DI: Número de períodos", minval=1)
iADXSuave = input(14,                            "[ADX] Suavizador do ADX: Número de períodos", minval=1)
iADXMin   = input(0,                             "[ADX] Filtro de valor mínimo do ADX", minval=0, maxval=100)
iADXMax   = input(100,                           "[ADX] Filtro de valor maximo do ADX", minval=10, maxval=100) 
iADXTrend = input(0,                             "[ADX] Filtro de Aumento/Diminuicao de Tendência: 0:Off 1:Ficando mais forte (valor maior que o anterior), -1:Ficando mais fraca (valor menor que o anterior)", minval=-1, maxval=1, step=1)
iADXPlot  = input("Sim",                         "[ADX] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"

dummyEstocastico = input(false, "[Estocastico]-----------------------------------------------------", type = input.bool )
iESTModo  = input(0,                                                       "[Estocastico] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iESTInv   = input("Nao",                                                   "[Estocastico] Inverter", options=["Sim", "Nao"]) =="Sim"
iESTForma = input("Linha %K suavizada acima/abaixo da linha %D suavizada", "[Estocastico] Forma de uso", options=["Cruzamento da linha %K suavizada com a linha %D suavizada", "Linha %K suavizada acima/abaixo da linha %D suavizada"])
iESTLen   = input(14,                                                      "[Estocastico] Numero de periodos", minval=1)
iESTSuavK = input(3,                                                       "[Estocastico] Suavizador da linha K", minval=0)
iESTSuavD = input(3,                                                       "[Estocastico] Suavizador da linha D", minval=0)
iESTMin   = input(100,                                                     "[Estocastico] Filtro Estocastico minimo", minval=0, maxval=100)
iESTMax   = input(0,                                                       "[Estocastico] Filtro Estocastico maximo", minval=0, maxval=100)
iESTPlot  = input("Sim",                                                   "[Estocastico] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyVWAP  = input(false, "[VWAP]------------------------------------------------------------------", type = input.bool )
iVWAPModo  = input(0,                                             "[VWAP] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iVWAPInv   = input("Nao",                                         "[VWAP] Inverter", options=["Sim", "Nao"]) =="Sim"
iVWAPForma = input("Compra acima do VWAP / Vende abaixo do VWAP", "[VWAP] Forma de uso: ", options=["Rompimento do VWAP", "Compra acima do VWAP / Vende abaixo do VWAP", "Vende acima do VWAP / Compra abaixo do VWAP"])
iVWAPPlot  = input("Sim",                                         "[VWAP] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyIFR  = input(false, "[IFR]--------------------------------------------------------------------", type = input.bool )
iIFRModo  = input(0,                                                        "[IFR] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iIFRInv   = input("Nao",                                                    "[IFR] Inverter", options=["Sim", "Nao"]) =="Sim"
iIFRForma = input("IFR acima/abaixo dos níveis sobrecomprado/sobrevendido", "[IFR] Forma de uso", options=["Cruzamento do IFR com os níveis", "IFR acima/abaixo dos níveis sobrecomprado/sobrevendido"])
iIFRSrc   = input(close,                                                    "[IFR] Valor usado")
iIFRLen   = input(14,                                                       "[IFR] Numero de periodos", minval=1)
iIFRMin   = input(20.0,                                                     "[IFR] Nível sobrevendido (inferior)", minval=0, maxval=100)
iIFRMax   = input(80.0,                                                     "[IFR] Nível sobrecomprado (superior)", minval=0, maxval=100)
iFRPPlot  = input("Sim",                                                    "[IFR] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyBB  = input(false, "[Bandas de Bollinger]-----------------------------------------------------", type = input.bool )
iBBModo  = input(0,                                   "[BB] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iBBInv   = input("Nao",                               "[BB] Inverter", options=["Sim", "Nao"]) =="Sim"
iBBForma = input("Cruzamento do preco com as bandas", "[BB] Forma de uso", options=["Cruzamento do preco com as bandas", "Preco acima/abaixo das bandas"])
iBBSrc   = input(close,                               "[BB] Fonte para Bolinger Bands")
iBBLen   = input(20,                                  "[BB] Numero de periodos", minval=1)
iBBDes   = input(2.0,                                 "[BB] Desvio", minval=0.001, maxval=50)
iBBPlot  = input("Sim",                               "[BB] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyATR = input(false, "[Stop TR]-----------------------------------------------------------------", type = input.bool )
iATRModo  = input(0,                                "[ATR] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iATRInv   = input("Nao",                            "[ATR] Inverter", options=["Sim", "Nao"]) =="Sim"
iATRForma = input("Mudanca no sentido do Stop ATR", "[ATR] Forma de uso", options=["Mudanca no sentido do Stop ATR", "Sentido do Stop ATR"])
iATRTipo  = input("Exponencial",                    "[ATR] Tipo de media", options=["Simples", "Exponencial"] )
iATRLen   = input(6,                                "[ATR] Numero de periodos", minval=1)
iATRMult  = input(3.5,                              "[ATR] Desvio/Multiplicador", minval=0.001, maxval=50)
iATRPlot  = input("Sim",                            "[ATR] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummySAR  = input(false, "[SAR Parabolico]---------------------------------------------------------", type = input.bool )
iSARModo  = input(0,                                      "[SAR] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iSARInv   = input("Nao",                                  "[SAR] Inverter", options=["Sim", "Nao"]) =="Sim"
iSARForma = input("Mudanca no sentido dos pontos do SAR", "[SAR] Forma de uso", options=["Mudanca no sentido dos pontos do SAR", "Sentido dos pontos do SAR"])
iSARFA    = input(0.02,                                   "[SAR] Fator de aceleracao", minval=0.001, maxval=50, step = 0.001)
iSARFI    = input(0.02,                                   "[SAR] Valor de incremento", minval=0.001, maxval=50, step = 0.001)
iSARLim   = input(0.20,                                   "[SAR] Valor maximo de fator", minval=0.001, maxval=50, step = 0.001)
iSARPlot  = input("Sim",                                  "[SAR] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyRisk2  = input(false, "[Criterios de Saida]---------------------------------------------------", type = input.bool )

// === RISK MANAGEMENT VALUE PREP ===
// if an input is less than 1, assuming not wanted so we assign 'na' value to disable it.
//iSaidaAll     = input("Nao", "[Saida] Sair se todos os indicadores selecionados para saída sinalizarem", options=["Sim","Nao"])=="Sim"


iEMartingale    = input(0,   "[Martingale] Dobrar posição na entrada seguinte a uma perda")

iEStopFixo    = input(17.00,   "[Stop fixo de perda] Stop Loss (Pontos)")
iETakeFixo    = input(0.00,   "[Stop fixo de ganho] Stop Gain/Take Profit (Pontos)")
iETSAtivar    = input(0.00,   "[Trailing Stop] Início/Ativacao (Pontos)")
iETSDistancia = input(0.00,    "[Trailing Stop] Distância (Pontos)")

iEParcialT    = input(0.0,   "[Realizacao parcial] Valor Execucao")
iEParcialBE =   input("Nao", "[Realizacao parcial] Break-even: Posicionar stop fixo de perda no preco de entrada apos realizacao parcial", options=["Sim","Nao"]) == "Sim"

dummyRisk4  = input(false, "-----------------------------------------------------------------------", type = input.bool )
iSDPerda    = input(800.0, "[Saida Diario] Stop diario de perda (Valor absoluto financeiro (R$))", minval = 0, step = 100)
iSDGanho    = input(100.0, "[Saida Diario] Stop diario de ganho (Valor absoluto financeiro (R$))", minval = 0 , step = 100)
iSDXTrades  = input(999,   "[Saida Diario] Parar apos X trades no dia", minval = 1)
iSDXTradesLost  = input(3, "[Saida Diario] Parar apos X trades Perdidas", minval = 1)

dummyRisk3  = input(false, "-----------------------------------------------------------------------", type = input.bool )
// Work time and Order time restrictions.
iTot   = input("0900-1200", "Horario inicial/final para abrir posicoes ", type=input.session)
iJanela1 = input ("1800-1810", "Janela De bloqueio de operacoes 1", type=input.session)
iJanela2 = input ("1800-1810", "Janela De bloqueio de operacoes 2", type=input.session)
iTwt   = input("0900-1659", "Horario final para zerar carteira", type=input.session)


dummyJanela  = input(false, "-----------------------------------------------------------------------", type = input.bool )
iTtz   = syminfo.timezone // input("GMT-3", "What is the Time Zone")
iTdate = input(20200101, " Data inicial para backtest: YYYYMMDD")
iTdias = input(365, "Dias apos a data inicial em backtest")


// Fix Tick on especial assets
iFixMinTick = input(0.0, "Ajusta o tick no Tradingview", minval=0.0, type=input.float)

// === DEPENDENCE AND FUNCTIONS ===
roundTo(v, t) =>
    r = round(v * (1/t)) / (1/t)

getNum(n, d) =>
    r = floor((n % pow(10, d)) / pow(10, d-1))

// === ESTRATEGIAS ===
mmEntrada = (iMMModo == 1 or iMMModo >= 3)
mmSaida   = iMMModo > 1
mmCurta   = 0.0
mmLonga   = 0.0
if iMMModo
	mmCurta := iff(iMMCurtaTipo == "Simples", sma(iMMCurtaSrc[iMMCurtaDes], iMMCurtaLen), ema(iMMCurtaSrc[iMMCurtaDes], iMMCurtaLen))
	mmLonga := iff(iMMLongaTipo == "Simples", sma(iMMLongaSrc[iMMLongaDes], iMMLongaLen), ema(iMMLongaSrc[iMMLongaDes], iMMLongaLen))
plot(iMMPlot and iMMModo ? mmCurta : na, "MM Curta", #90CAF9, 1, plot.style_line, 0, 15)
plot(iMMPlot and iMMModo ? mmLonga : na, "MM Longa", #9575CD, 2, plot.style_line, 0, 15)

eMM() =>
	r = 0
	if iMMModo == 0
	    r := 0
	else if iMMForma == "Cruzamento das Medias"
		if crossover(mmCurta, mmLonga)
			r := 1
		else if crossunder(mmCurta, mmLonga)
			r := -1
	else if iMMForma == "Media curta acima/abaixo da longa"
		if mmCurta > mmLonga
			r := 1
		else if mmCurta < mmLonga
			r := -1
	if iMMInv
	    r := r == 1? -1: r == -1? 1: r
	r

hlEntrada = (iHLModo == 1 or iHLModo >= 3)
hlSaida   = iHLModo > 1
hlHigh    = 0.0
hlLow     = 0.0
hlH       = 0.0
hlL       = 0.0
hlSentido = 0.0
hlPlot    = float(na)
hlColor   = color.white

if iHLModo
    displace = 1
	hlHigh := sma(high, iHLLen)
	hlLow  := sma(low, iHLLen)
	hlSentido := close > hlHigh[displace]? 1: close < hlLow[displace]? -1: nz(hlSentido[1])

	hlH := highest(close, iHLLen)
	hlL := lowest(close, iHLLen)
	
	hlPlot  := hlSentido == 1? hlL: hlH
	hlColor := hlSentido != hlSentido[1]? hlColor: hlSentido == 1 ? color.green: hlSentido == -1? color.red: color.yellow
plot(iHLPlot and iHLModo ? hlPlot: na, "Hi Lo Activator", hlColor, 2, plot.style_line, 0, 50)

eHiLo() =>
	r = 0
	if iHLModo == 0
	    r := 0
	else if iHLForma == "Sentido da escada do HiLo"
		if hlSentido == 1
			r := 1
		else if hlSentido == -1
			r := -1
	else if iHLForma == "Mudanca no sentido da escada do HiLo"
		if hlSentido == 1 and hlSentido[1] == -1
			r := 1
		else if hlSentido == -1 and hlSentido[1] == 1
			r := -1
	if iHLInv
	    r := r == 1? -1: r == -1? 1: r
	r

macdEntrada = (iMACDModo == 1 or iMACDModo >= 3)
macdSaida   = iMACDModo > 1
var macdTipo = iMACDTipo == "Simples" ? true : false
var macdLine = float(na)
var signalLine = float(na)
if iMACDModo
    macdLine := ema(iMACDSrc,iMACDCurta) -  ema(iMACDSrc, iMACDLonga)
    sma_3 = sma(macdLine, iMACDSinal)
    ema_3 = ema(macdLine, iMACDSinal)
    signalLine := macdTipo ? sma_3 : ema_3

plot(iMACDPlot ? macdLine + strategy.position_avg_price: na,"Linha MACD",color.blue)
plot(iMACDPlot ? signalLine + strategy.position_avg_price: na,"Sinal MACD",color.red)

eMACD() =>
	r = 0
	if iMACDModo == 0
	    r := 0
	else if iMACDForma == "Cruzamento da linha MACD com a linha de sinal"
		if crossover(macdLine, signalLine)
			r :=  1
		else if crossunder(macdLine, signalLine)
			r := -1
	else if iMACDForma == "Linha MACD acima/abaixo da linha de sinal"
		if macdLine > signalLine
			r := 1
		else if macdLine < signalLine
			r := -1
	
	if iMACDInv
	    r := r == 1? -1: r == -1? 1: r
	
	if iMACDFiltro
		if r == 1 and macdLine < iMACDFilVal
			r := 0
		else if r == -1 and macdLine > iMACDFilVal
			r := 0
	r
	

adxEntrada = (iADXModo == 1 or iADXModo >= 3)
adxSaida   = iADXModo > 1
adxUp = 0.0
adxDown = 0.0
adxPlusDM = 0.0
adxMinusDM = 0.0
adxTrur = 0.0
adxPlus = float(na)
adxMinus = float(na)
adxSum = 0.0
adxLine = float(na)
if iADXModo
	adxUp := change(high)
	adxDown := -change(low)
	adxPlusDM := na(adxUp) ? na : (adxUp > adxDown and adxUp > 0 ? adxUp : 0)
	adxMinusDM := na(adxDown) ? na : (adxDown > adxUp and adxDown > 0 ? adxDown : 0)
	adxTrur := rma(tr, iADXLen)
	adxPlus := fixnan(100 * rma(adxPlusDM, iADXLen) / adxTrur)
	adxMinus := fixnan(100 * rma(adxMinusDM, iADXLen) / adxTrur)
	adxSum := adxPlus + adxMinus
	adxLine := 100 * rma(abs(adxPlus - adxMinus) / (adxSum == 0 ? 1 : adxSum), iADXSuave)
	
plot(iADXPlot ? adxPlus : na,"DI+", color.blue)
plot(iADXPlot ? adxMinus : na,"DI-", color.orange)
plot(iADXPlot ? adxLine : na,"ADX", color.red)


eADX() =>
	r = 0
	if iADXModo == 0
	    r := 0
	else if iADXForma == "Cruzamento do DI+ com o DI-"
		if crossover(adxPlus, adxMinus)
			r := 1
		else if crossover(adxMinus, adxPlus)
			r := -1
	else if iADXForma == "DI+ acima/abaixo do DI-"
		if adxPlus > adxMinus
			r := 1
		else if adxMinus > adxPlus
			r := -1
	if iADXInv
        r := r == 1? -1: r == -1? 1: r

	if adxLine < iADXMin or adxLine > iADXMax
		r := 0
	else if iADXTrend > 0 and (adxLine <= adxLine[1])
		r := 0
	else if iADXTrend < 0 and (adxLine >= adxLine[1])
		r := 0
	r

estEntrada = (iESTModo == 1 or iESTModo >= 3)
estSaida   = iESTModo > 1
estK = float(na)
estD = float(na)
if iESTModo
	estK := sma(stoch(close, high, low, iESTLen), iESTSuavK)
	estD := sma(estK, iESTSuavD)

	
plot(iESTPlot ? estK + strategy.position_avg_price : na,"K%", color.blue)
plot(iESTPlot ? estD + strategy.position_avg_price : na,"D%", color.orange)

eEST() =>
	r = 0
	if iESTModo == 0
	    r := 0
	else if iESTForma == "Cruzamento da linha %K suavizada com a linha %D suavizada"
		if crossover(estK, estD)
			r := 1
		else if crossunder(estK, estD)
			r := -1
	else if iESTForma == "Linha %K suavizada acima/abaixo da linha %D suavizada"
		if estK > estD
			r := 1
		else if estK < estD
			r := -1
	if iESTInv
	    r := r == 1? -1: r == -1? 1: r

	if (r == 1 and estK > iESTMin) or (r == -1 and estK < iESTMax)
		r := 0
	r

vwEntrada = (iVWAPModo == 1 or iVWAPModo >= 3)
vwSaida   = iVWAPModo > 1
plot(iVWAPPlot and iVWAPModo ? vwap : na, "VWAP", #9E9E9E, 3, plot.style_line, 0, 15)

eVWAP() =>
	r = 0
	if iVWAPModo == 0
	    r := 0
	else if iVWAPForma == "Rompimento do VWAP"
		if crossover(close, vwap)
			r := 1
		else if crossunder(close, vwap)
			r := -1
	else if iVWAPForma == "Compra acima do VWAP / Vende abaixo do VWAP"
		if close > vwap
			r := 1
		else if close < vwap
			r := -1
	else if iVWAPForma == "Vende acima do VWAP / Compra abaixo do VWAP"
		if close > vwap
			r := -1
		else if close < vwap
			r := 1
	if iVWAPInv
        r := r == 1? -1: r == -1? 1: r

	r

ifrEntrada = (iIFRModo == 1 or iIFRModo >= 3)
ifrSaida   = iIFRModo > 1
ifrUp   = 0.0
ifrDown = 0.0
ifr     = 0.0
if iIFRModo
	ifrUp   := rma(max(change(iIFRSrc), 0), iIFRLen)
	ifrDown := rma(-min(change(iIFRSrc), 0), iIFRLen)
	ifr     := ifrDown == 0 ? 100 : ifrUp == 0 ? 0 : 100 - (100 / (1 + ifrUp / ifrDown))
eIFR() =>
	r = 0
	if iIFRModo == 0
	    r := 0
	else if iIFRForma == "Cruzamento do IFR com os níveis"
		if crossover(ifr, iIFRMin)
			r := 1
		else if crossunder(ifr, iIFRMax)
			r := -1
	else if iIFRForma == "IFR acima/abaixo dos níveis sobrecomprado/sobrevendido"
		if ifr < iIFRMin
			r := 1
		else if ifr > iIFRMax
			r := -1
	if iIFRInv
	    r := r == 1? -1: r == -1? 1: r
	r

bbEntrada = (iBBModo == 1 or iBBModo >= 3)
bbSaida   = iBBModo > 1
bbBase    = 0.0
bbDesvio  = 0.0
bbUp      = 0.0
bbDown    = 0.0
if iBBModo
	bbBase   := sma(iBBSrc, iBBLen)
	bbDesvio := iBBDes * stdev(iBBSrc, iBBLen) 
	bbUp     := bbBase + bbDesvio
	bbDown   := bbBase - bbDesvio
	
plot(iBBPlot and iBBModo? bbBase: na, "BB Media base", #fb8c00, 1, plot.style_circles, 0, 15)
plot(iBBPlot and iBBModo? bbUp: na, "BB Up Line", #fb8c00, 1, plot.style_line, 0, 15)
plot(iBBPlot and iBBModo? bbDown: na, "BB Bottom Line", #fb8c00, 1, plot.style_line, 0, 15)

eBB() =>
	r = 0
	if iBBModo == 0
	    r := 0
	else if iBBForma == "Cruzamento do preco com as bandas"
		if crossover(iBBSrc, bbDown)
			r := 1
		else if crossunder(iBBSrc, bbUp)
			r := -1
	else if iBBForma == "Preco acima/abaixo das bandas"
		if iBBSrc < bbDown
			r := 1
		else if iBBSrc > bbUp
			r := -1
	if iBBInv
	    r := r == 1? -1: r == -1? 1: r
	r


atrEntrada = (iATRModo == 1 or iATRModo >= 3)
atrSaida   = iATRModo > 1
atrX     = float(na)
atrLoss  = float(na)
atrStop  = float(na)
atrPos   = float(na)
atrColor = color.black
if iATRModo
	atrX     := atr(iATRLen)
	atrLoss  := iATRMult * atrX
	atrStop  := iff(close > nz(atrStop[1], 0) and close[1] > nz(atrStop[1], 0), max(nz(atrStop[1]), close - atrLoss), iff(close < nz(atrStop[1], 0) and close[1] < nz(atrStop[1], 0), min(nz(atrStop[1]), close + atrLoss), iff(close > nz(atrStop[1], 0), close - atrLoss, close + atrLoss)))
	atrPos   := iff(close[1] < nz(atrStop[1], 0) and close > nz(atrStop[1], 0), 1, iff(close[1] > nz(atrStop[1], 0) and close < nz(atrStop[1], 0), -1, nz(atrPos[1], 0)))
	atrColor := atrPos == -1 ? color.red: atrPos == 1 ? color.green : color.blue 
	
plot(iATRPlot and iATRModo? atrStop: na, "Stop ATR", atrColor, 1, plot.style_line, 0, 15) 

eATR() =>
	r = 0
	if iATRModo == 0
	    r := 0
	else if iATRForma == "Mudanca no sentido do Stop ATR"
		if crossover(close, atrStop)
			r := 1
		else if crossunder(close, atrStop)
			r := -1
	else if iATRForma == "Sentido do Stop ATR"
		if close > atrStop
			r := 1
		else if close < atrStop
			r := -1
    if iATRInv
	    r := r == 1? -1: r == -1? 1: r
	r


sarEntrada = (iSARModo == 1 or iSARModo >= 3)
sarSaida   = iSARModo > 1
sarVal   = 0.0
sarColor = color.black
if iSARModo
	sarVal   := sar(iSARFA, iSARFI, iSARLim)
	sarColor := iff(close > sarVal, #4dd0e1, #f06292)

plot(iSARPlot and iSARModo? sarVal: na, "Parabolic SAR", sarColor, 2, plot.style_circles, 0, 15)

eSAR() =>
	r = 0
	if iSARModo == 0
	    r := 0
	else if iSARForma == "Mudanca no sentido dos pontos do SAR"
		if crossover(close, sarVal)
			r := 1
		else if crossunder(close, sarVal)
			r := -1
	else if iSARForma == "Sentido dos pontos do SAR"
		if close > sarVal
			r := 1
		else if close < sarVal
			r := -1
    if iSARInv
	    r := r == 1? -1: r == -1? 1: r
	r



// === MANEJO DE DAY TRADE ===
var netProfit = 0.0
var intradayFilledOrderLastDay = 0
var intradayFilledOrder = 0
var intradayLostdOrderLastDay = 0
var intradayLostOrder = 0
var yesterday = 0.0

if yesterday != dayofmonth
    yesterday := dayofmonth
	netProfit := strategy.netprofit
	intradayFilledOrderLastDay := strategy.closedtrades
	intradayLostdOrderLastDay := strategy.losstrades
	intradayFilledOrder := 0
	intradayLostOrder := 0

intradayFilledOrder := strategy.closedtrades - intradayFilledOrderLastDay
intradayLostOrder := strategy.losstrades - intradayLostdOrderLastDay

//strategy.risk.max_intraday_loss(iSDPerda, strategy.cash)
//strategy.risk.max_intraday_filled_orders(iSDXTrades+1)

dayProfit = strategy.netprofit - netProfit + strategy.openprofit
dayStop = dayProfit >= iSDGanho 
dayStop := dayStop or dayProfit <= -iSDPerda 
dayStop := dayStop or intradayLostOrder >= iSDXTradesLost  
dayStop := dayStop or intradayFilledOrder >= iSDXTrades


// === DAY TRADE TIME RESTRICTION ===
// you can put fixed values and comment the input to have a cleanner menu.
wy = getNum(iTdate, 8)*1000 + getNum(iTdate, 7)*100 + getNum(iTdate, 6)*10 + getNum(iTdate, 5)
wm = getNum(iTdate, 4)*10 + getNum(iTdate, 3)
wd = getNum(iTdate, 2)*10 + getNum(iTdate, 1)

wot = time('1', iTot)
wwt = time('1', iTwt)
wjan1 = time ('1', iJanela1)
wjan2 = time ('1', iJanela2)


woti = timestamp(iTtz, wy, wm, wd, 0, 0)
wotf = woti + (iTdias * 86400000)
inRangeToProcesBt = time>=woti and time <=wotf

bool orderTime =  time(timeframe.period, iTot) 
orderTime := orderTime and not dayStop 
orderTime := orderTime and inRangeToProcesBt 
orderTime := orderTime and not wjan1 and not wjan2

workTime  = time(timeframe.period, iTwt)

// bgcolor(workTime ? na: #FFFFFF, transp=80)
bgcolor(orderTime? color.white: workTime ? color.yellow: color.orange, transp=80)

// === STRATEGY FUNCTIONS ===

// === SERIES SETUP  GENERAL ===
minTick  = iFixMinTick ? iFixMinTick: syminfo.mintick

// === RISK MANAGEMENT VALUE PREP ===
// if an input is less than 1, assuming not wanted so we assign 'na' value to disable it.
eStop = iEStopFixo    > 0   ? iEStopFixo    / minTick: na
eTake = iETakeFixo    > 0   ? iETakeFixo    / minTick: na
eTS   = iETSAtivar    > 0   ? iETSAtivar    / minTick: na
eTSD  = iETSDistancia > 0   ? iETSDistancia / minTick: na
eParc = iEParcialT    > 0   ? iEParcialT    / minTick: na

//eStop = iEStopFixo    > 0   ? iEStopFixo    : na
//eTake = iETakeFixo    > 0   ? iETakeFixo    : na
//eTS   = iETSAtivar    > 0   ? iETSAtivar    : na
//eTSD  = iETSDistancia > 0   ? iETSDistancia : na
//eParc = iEParcialT    > 0   ? iEParcialT    : na


cEntradas() =>
	c = ""
	c := mmEntrada   ? c + "A" : c
	c := hlEntrada   ? c + "B" : c
	c := macdEntrada ? c + "C" : c
	c := adxEntrada  ? c + "D" : c
	c := estEntrada  ? c + "E" : c
	c := vwEntrada   ? c + "F" : c
	c := ifrEntrada  ? c + "G" : c
	c := bbEntrada   ? c + "H" : c
	c := atrEntrada  ? c + "I" : c
	c := sarEntrada  ? c + "J" : c
	c

cSaidas() =>
	c = ""
	c := mmSaida   ? c + "A" : c
	c := hlSaida   ? c + "B" : c
	c := macdSaida ? c + "C" : c
	c := adxSaida  ? c + "D" : c
	c := estSaida  ? c + "E" : c
	c := vwSaida   ? c + "F" : c
	c := ifrSaida  ? c + "G" : c
	c := bbSaida   ? c + "H" : c
	c := atrSaida  ? c + "I" : c
	c := sarSaida  ? c + "J" : c
	c
	
//long
c = ""
c := mmEntrada   and eMM()   > 0? c + "A": c
c := hlEntrada   and eHiLo() > 0? c + "B": c
c := macdEntrada and eMACD() > 0? c + "C": c
c := adxEntrada  and eADX()  > 0? c + "D": c
c := estEntrada  and eEST()  > 0? c + "E": c
c := vwEntrada   and eVWAP() > 0? c + "F": c
c := ifrEntrada  and eIFR()  > 0? c + "G": c
c := bbEntrada   and eBB()   > 0? c + "H": c
c := atrEntrada  and eATR()  > 0? c + "I": c
c := sarEntrada  and eSAR()  > 0? c + "J": c
indicadoresCompra = c

entradaCompra() =>
	compra = indicadoresCompra != "" and indicadoresCompra == cEntradas()
    //compra := compra and not (iPrevinir and indicadoresCompra[1] == indicadoresCompra)
	compra := compra and not dayStop and orderTime
	compra := compra and barstate.isconfirmed 
	compra := compra and ((iOPModo == 4 and strategy.position_size <= 0) or ((iOPModo == 3 or iOPModo == 1) and strategy.position_size == 0))
	compra := compra and (not iPrevinir or indicadoresCompra[1] != indicadoresCompra or intradayFilledOrder == 0)
	compra

	
//short
c := ""
c := mmEntrada   and eMM()   < 0? c + "A": c
c := hlEntrada   and eHiLo() < 0? c + "B": c
c := macdEntrada and eMACD() < 0? c + "C": c
c := adxEntrada  and eADX()  < 0? c + "D": c
c := estEntrada  and eEST()  < 0? c + "E": c
c := vwEntrada   and eVWAP() < 0? c + "F": c
c := ifrEntrada  and eIFR()  < 0? c + "G": c
c := bbEntrada   and eBB()   < 0? c + "H": c
c := atrEntrada  and eATR()  < 0? c + "I": c
c := sarEntrada  and eSAR()  < 0? c + "J": c
indicadoresVenda = c

entradaVenda() =>
	venda = indicadoresVenda != "" and indicadoresVenda == cEntradas()
    //venda := venda and not (iPrevinir and indicadoresVenda[1] == indicadoresVenda)
	venda := venda and not dayStop and orderTime
	venda := venda and barstate.isconfirmed
	venda := venda and ((iOPModo == 4 and strategy.position_size >= 0) or ((iOPModo == 2 or iOPModo == 3) and strategy.position_size == 0))
    venda := venda and (not iPrevinir or indicadoresVenda[1] != indicadoresVenda or intradayFilledOrder == 0)
	venda

//long
saidaCompra() =>
	c = ""
	c := mmSaida   and eMM()   < 0? c + "A": c
	c := hlSaida   and eHiLo() < 0? c + "B": c
	c := macdSaida and eMACD() < 0? c + "C": c
	c := adxSaida  and eADX()  < 0? c + "D": c
	c := estSaida  and eEST()  < 0? c + "E": c
	c := vwSaida   and eVWAP() < 0? c + "F": c
	c := ifrSaida  and eIFR()  < 0? c + "G": c
	c := bbSaida   and eBB()   < 0? c + "H": c
	c := atrSaida  and eATR()  < 0? c + "I": c
	c := sarSaida  and eSAR()  < 0? c + "J": c
	compra = strategy.position_size > 0
	compra := compra and c != "" and c == cSaidas()
	compra := compra and workTime //or (iSaidaAll? c == cSaidas(): c > 0)
	compra := compra and barstate.isconfirmed
	compra
	  

// short
saidaVenda() =>
	c = ""
	c := mmSaida   and eMM()   > 0? c + "A": c
	c := hlSaida   and eHiLo() > 0? c + "B": c
	c := macdSaida and eMACD() > 0? c + "C": c
	c := adxSaida  and eADX()  > 0? c + "D": c
	c := estSaida  and eEST()  > 0? c + "E": c
	c := vwSaida   and eVWAP() > 0? c + "F": c
	c := ifrSaida  and eIFR()  > 0? c + "G": c
	c := bbSaida   and eBB()   > 0? c + "H": c
	c := atrSaida  and eATR()  > 0? c + "I": c
	c := sarSaida  and eSAR()  > 0? c + "J": c
	venda = strategy.position_size < 0
	venda := venda and c != "" and c == cSaidas()
	venda := venda and workTime //or (iSaidaAll? c == cSaidas(): c > 0)
	venda := venda and barstate.isconfirmed
	venda

// === MARTIGALE =========
var initialOrderAmount = float(na)
var martigaleOrderMultiplier = 1

if nz(initialOrderAmount) == 0  and strategy.position_size != 0
    initialOrderAmount := abs(strategy.position_size)

var lossTrades = 0
var wintrades = 0
if iEMartingale > 0
    if (entradaCompra() or entradaVenda()) 
        
        if lossTrades < strategy.losstrades 
            if martigaleOrderMultiplier < pow(2, iEMartingale) 
                martigaleOrderMultiplier := martigaleOrderMultiplier * 2
            else 
                martigaleOrderMultiplier := 1
            lossTrades := strategy.losstrades
            
        if (wintrades < strategy.wintrades) 
            martigaleOrderMultiplier := 1
            wintrades := strategy.wintrades


// === STRATEGY ===
openProfit = "$ " + tostring (strategy.openprofit)

if strategy.position_size == 0
    ordersToBuy = initialOrderAmount * martigaleOrderMultiplier
    strategy.entry("Compra", strategy.long, qty=ordersToBuy, when=entradaCompra(), comment = "EC")
    strategy.entry("Venda", strategy.short, qty=ordersToBuy, when=entradaVenda(), comment = "EV")
else
    ordersToRevert = initialOrderAmount * 1 + (initialOrderAmount * martigaleOrderMultiplier)
    strategy.order("Compra", strategy.long, qty=ordersToRevert, when=entradaCompra(), comment = "RC " + openProfit)
    strategy.order("Venda", strategy.short, qty=ordersToRevert, when=entradaVenda(), comment =  "RV " + openProfit)


strategy.close("Compra", when=saidaCompra(), comment = "SC " + openProfit)
strategy.close("Venda", when=saidaVenda(), comment = "SV " + openProfit)

ninTakeNotZero() =>
    r = nz(eParc)
    if nz(eParc)>0 and nz(eTake)>0
        r := min(eParc, eTake)
    else if nz(eTake)>0
        r := nz(eTake)
    r

if strategy.position_size != 0 
    t = ninTakeNotZero()
    if eParc == t and abs(strategy.position_size) >= initialOrderAmount 
        strategy.exit("SaidaParcial", qty_percent=50, profit=eParc, trail_points=eTS, trail_offset=eTSD, loss=eStop, comment = "Saida Take Parcial")

    l = iEParcialBE and nz(eParc) > 0? eParc: eStop 
    strategy.exit("Saida", profit=eTake, trail_points=eTS, trail_offset=eTSD, loss=l, comment = "Saida Take/Loss")

    getOut = (not workTime or dayStop) and strategy.position_size != 0
    
    strategy.cancel_all(getOut)
    strategy.close_all(getOut, comment = "Close ALL")

//plot(syminfo.mintick, "Valor do Tick")
