//@version=4
strategy(title="Tangram Bot 2", shorttitle="Parametros TANGRAM", slippage=0, overlay=true, pyramiding=0, calc_on_order_fills=false, calc_on_every_tick=true, backtest_fill_limits_assumption=1, default_qty_value=10, linktoseries=false, commission_type=strategy.commission.cash_per_contract, commission_value=2.5)
//WIN use slipage = 30
//WDO use slipage = 5

// === GENERAL INPUTS === 

// Indicadores Tecnicos
iOPModo      = input(4, "[Estrategia] Sentido das operacoes: 0:Off 1:Comprado, 2:Vendido, 3:Ambos sem Reversao, 4:Ambos com Reversao", minval=0, maxval=4, step=1)
//iPrevinir    = input(true, "[Estrategia] Prevenir entradas no mesmo sentido apos uma saida")
iPrevinir    = input("Sim",  "[Estrategia] Habilitar bloqueio de nova entrada no mesmo dia apos uma saida", options=["Sim","Nao"])=="Sim"

dummyMM= input(false, "[Medias Moveis]-------------------------------------------------------------", type = input.bool )
iMMModo      = input(1,                                   "[MM] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iMMInv       = input("Nao",                               "[MM] Inverter", options=["Sim", "Nao"]) =="Sim"
iMMForma     = input("Media curta acima/abaixo da longa", "[MM] Forma de uso", options=["Cruzamento das Medias", "Media curta acima/abaixo da longa"])
iMMCurtaTipo = input("Exponencial",                       "[MM] Media Curta: Tipo", options=["Simples", "Exponencial"] )
iMMCurtaLen  = input(9,                                  "[MM] Media curta: Numero de periodos", minval=1)
iMMCurtaDes  = input(0,                                   "[MM] Media Curta: Deslocamento", minval=0)
iMMCurtaSrc  = input(close,                               "[MM] Media Curta: Fonte")
iMMLongaTipo = input("Exponencial",                       "[MM] Media Longa: Tipo", options=["Simples", "Exponencial"])
iMMLongaLen  = input(40,                                  "[MM] Media longa: Numero de periodos", minval=1)
iMMLongaDes  = input(0,                                   "[MM] Media Longa: Deslocamento", minval=0)
iMMLongaSrc  = input(close,                               "[MM] Media Longa: Fonte")
iMMPlot      = input("Sim",                               "[MM] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"



dummyHilo= input(false, "[HiLo Activator]----------------------------------------------------------", type = input.bool )
iHLModo  = input(0,                                      "[HiLo] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iHLInv   = input("Nao",                                  "[HiLo] Inverter" , options=["Sim", "Nao"]) =="Sim"
iHLForma = input("Sentido da escada do HiLo",            "[HiLo] Modo de Operacao", options=["Mudanca no sentido da escada do HiLo", "Sentido da escada do HiLo"])
iHLLen   = input(13,                                     "[HiLo] Numero de periodos", minval=1, step=1)
iHLDist  = input(1,                                      "[HiLo] Distancia", minval=0)
iHLPlot  = input("Sim",                                  "[HiLo] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyMACD= input(false, "[MACD]-------------------------------------------------------------------", type = input.bool )
iMACDModo   = input(0,                                               "[MACD] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iMACDInv    = input("Nao",                                           "[MACD] Inverter" , options=["Sim", "Nao"]) =="Sim"
iMACDForma  = input("Cruzamento da linha MACD com a linha de sinal", "[MACD] Modo de Operacao", options=["Cruzamento da linha MACD com a linha de sinal", "Linha MACD acima/abaixo da linha de sinal"])
iMACDSrc    = input(close,                                           "[MACD] Valor usado")
iMACDTipo   = input("Exponencial",                                   "[MACD] Tipo de media", options=["Simples","Exponencial"])
iMACDCurta  = input(12,                                              "[MACD] Media curta: Numero de periodos", minval=1)
iMACDLonga  = input(26,                                              "[MACD] Media longa: Numero de periodos", minval=2)
iMACDSinal  = input(9,                                               "[MACD] Linha de sinal: Numero de periodos", minval=1)
iMACDFiltro = input(false,                                           "[MACD] Usar filtro para validar MACD")
iMACDFilVal = input(0.0,                                             "[MACD] Filtro para comprar/vender apenas com MACD abaixo/acima do valor do filtro", minval=0)
iMACDPlot   = input("Sim",                                           "[MACD] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyADX= input(false, "[ADX - DI+/DI-]------------------------------------------------------------", type = input.bool )
iADXModo  = input(0,                             "[ADX] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iADXInv   = input("Nao",                         "[ADX] Inverter", options=["Sim", "Nao"]) =="Sim"
iADXForma = input("Cruzamento do DI+ com o DI-", "[ADX] Forma de uso", options=["Cruzamento do DI+ com o DI-", "DI+ acima/abaixo do DI-"])
iADXLen   = input(14,                            "[ADX] DI: Numero de periodos", minval=1)
iADXSuave = input(14,                            "[ADX] Suavizador do ADX: Numero de periodos", minval=1)
iADXMin   = input(0,                             "[ADX] Filtro de valor minimo do ADX", minval=0, maxval=100)
iADXMax   = input(100,                           "[ADX] Filtro de valor maximo do ADX", minval=10, maxval=100) 
iADXTrend = input(0,                             "[ADX] Filtro de Aumento/Diminuicao de Tendência: 0:Off 1:Ficando mais forte (valor maior que o anterior), -1:Ficando mais fraca (valor menor que o anterior)", minval=-1, maxval=1, step=1)
iADXPlot  = input("Sim",                         "[ADX] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"
 
dummyEstocastico = input(false, "[Estocastico]-----------------------------------------------------", type = input.bool )
iESTModo  = input(0,                                                       "[Estocastico] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iESTInv   = input("Nao",                                                   "[Estocastico] Inverter", options=["Sim", "Nao"]) =="Sim"
iESTForma = input("Linha %K suavizada acima/abaixo da linha %D suavizada", "[Estocastico] Forma de uso", options=["Cruzamento da linha %K suavizada com a linha %D suavizada", "Linha %K suavizada acima/abaixo da linha %D suavizada"])
iESTLen   = input(3,                                                       "[Estocastico] Numero de periodos", minval=1)
iESTSuavK = input(3,                                                       "[Estocastico] Suavizador da linha K", minval=0)
iESTSuavD = input(3,                                                       "[Estocastico] Suavizador da linha D", minval=0)
iESTMax   = input(80,                                                      "[Estocastico] Filtro Estocastico maximo(Superior)", minval=0, maxval=100)
iESTMin   = input(20,                                                      "[Estocastico] Filtro Estocastico minimo(Inferiior)", minval=0, maxval=100)
iESTPlot  = input("Sim",                                                   "[Estocastico] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyVWAP  = input(false, "[VWAP]------------------------------------------------------------------", type = input.bool )
iVWAPModo  = input(0,                                             "[VWAP] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iVWAPInv   = input("Nao",                                         "[VWAP] Inverter", options=["Sim", "Nao"]) =="Sim"
iVWAPForma = input("Compra acima do VWAP / Vende abaixo do VWAP", "[VWAP] Forma de uso: ", options=["Rompimento do VWAP", "Compra acima do VWAP / Vende abaixo do VWAP", "Vende acima do VWAP / Compra abaixo do VWAP"])
iVWAPPlot  = input("Sim",                                         "[VWAP] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyIFR  = input(false, "[IFR]--------------------------------------------------------------------", type = input.bool )
iIFRModo  = input(0,                                                        "[IFR] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iIFRInv   = input("Nao",                                                    "[IFR] Inverter", options=["Sim", "Nao"]) =="Sim"
iIFRForma = input("IFR acima/abaixo dos niveis sobrecomprado/sobrevendido", "[IFR] Forma de uso", options=["Cruzamento do IFR com os niveis", "IFR acima/abaixo dos niveis sobrecomprado/sobrevendido"])
iIFRSrc   = input(close,                                                    "[IFR] Valor usado")
iIFRLen   = input(14,                                                       "[IFR] Numero de periodos", minval=1)
iIFRMin   = input(20.0,                                                     "[IFR] Nivel sobrevendido (inferior)", minval=0, maxval=100)
iIFRMax   = input(80.0,                                                     "[IFR] Nivel sobrecomprado (superior)", minval=0, maxval=100)
iIFRPlot  = input("Sim",                                                    "[IFR] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyBB  = input(false, "[Bandas de Bollinger]-----------------------------------------------------", type = input.bool )
iBBModo  = input(0,                                   "[BB] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iBBInv   = input("Nao",                               "[BB] Inverter", options=["Sim", "Nao"]) =="Sim"
iBBForma = input("Cruzamento do preco com as bandas", "[BB] Forma de uso", options=["Cruzamento do preco com as bandas", "Preco acima/abaixo das bandas"])
iBBSrc   = input(close,                               "[BB] Fonte para Bolinger Bands")
iBBLen   = input(14,                                  "[BB] Numero de periodos", minval=1)
iBBDes   = input(2.0,                                 "[BB] Desvio", minval=0.001, maxval=50)
iBBPlot  = input("Sim",                               "[BB] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyATR = input(false, "[Stop ATR]-----------------------------------------------------------------", type = input.bool )
iATRModo  = input(0,                                "[ATR] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iATRInv   = input("Nao",                            "[ATR] Inverter", options=["Sim", "Nao"]) =="Sim"
iATRForma = input("Mudanca no sentido do Stop ATR", "[ATR] Forma de uso", options=["Mudanca no sentido do Stop ATR", "Sentido do Stop ATR"])
iATRTipo  = input("Exponencial",                    "[ATR] Tipo de media", options=["Simples", "Exponencial"] )
iATRLen   = input(6,                               "[ATR] Numero de periodos", minval=1)
iATRMult  = input(2,                                "[ATR] Desvio/Multiplicador", minval=0.001, maxval=50, step=0.1)
iATRPlot  = input("Sim",                            "[ATR] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummySAR  = input(false, "[SAR Parabolico]---------------------------------------------------------", type = input.bool )
iSARModo  = input(0,                                      "[SAR] Modo de Operacao: 0:Off 1:Entrada, 2:Saida, 3:Ambos", minval=0, maxval=3, step=1)
iSARInv   = input("Nao",                                  "[SAR] Inverter", options=["Sim", "Nao"]) =="Sim"
iSARForma = input("Mudanca no sentido dos pontos do SAR", "[SAR] Forma de uso", options=["Mudanca no sentido dos pontos do SAR", "Sentido dos pontos do SAR"])
iSARFA    = input(0.02,                                   "[SAR] Fator de aceleracao", minval=0.001, maxval=50, step = 0.001)
iSARFI    = input(0.02,                                   "[SAR] Valor de incremento", minval=0.001, maxval=50, step = 0.001)
iSARLim   = input(0.20,                                   "[SAR] Valor maximo de fator", minval=0.001, maxval=50, step = 0.001)
iSARPlot  = input("Sim",                                  "[SAR] Plotar Indice no Grafico", options=["Sim","Nao"]) == "Sim"


dummyRisk2  = input(false, "[Criterios de Saida]---------------------------------------------------", type = input.bool )

// === RISK MANAGEMENT VALUE PREP ===
// if an input is less than 1, assuming not wanted so we assign 'na' value to disable it.
iSaidaAll     = input("Nao", "[Saida] Sair se todos os indicadores selecionados para saida sinalizarem", options=["Sim","Nao"])=="Sim"


iEMartingale   = input(0,      "[Martingale] Dobrar posição na entrada seguinte a uma perda")

iEStopFixo    = input(0.00,   "[Stop fixo de perda] Stop Loss (Pontos)", step = .5)
iETakeFixo    = input(0.00,  "[Stop fixo de ganho] Stop Gain/Take Profit (Pontos)", step = .5)
iETSAtivar    = input(0.00,   "[Trailing Stop] Inicio/Ativacao (Pontos)", step = .5)
iETSDistancia = input(0.00,   "[Trailing Stop] Distância (Pontos)", step = .5)

iEParcialT    = input(0.0,   "[Realizacao parcial] Valor Execucao", step = .5)
iEParcialBE   = input("Nao", "[Realizacao parcial] Break-even: Posicionar stop fixo de perda no preco de entrada apos realizacao parcial", options=["Sim","Nao"]) == "Sim"

dummyRisk4      = input(false, "-----------------------------------------------------------------------", type = input.bool )
iSDPerda        = input(999900.0, "[Saida Diario] Stop diario de perda (Valor absoluto financeiro (R$))", minval = 0, step = 100)
iSDGanho        = input(600.0, "[Saida Diario] Stop diario de ganho (Valor absoluto financeiro (R$))", minval = 0, step = 100)
iSDXTrades      = input(1,   "[Saida Diario] Parar apos X trades no dia", minval = 1)
iSDXTradesLost  = input(99999,   "[Saida Diario] Parar apos X trades Perdidas", minval = 1)

dummyRisk3  = input(false, "-----------------------------------------------------------------------", type = input.bool )
// Work time and Order time restrictions.
iTot     = input("0900-1630", "Horario inicial/final para abrir posicoes ", type=input.session)
iJanela1 = input("1800-1810", "Janela De bloqueio de operacoes 1", type=input.session)
iJanela2 = input("1800-1810", "Janela De bloqueio de operacoes 2", type=input.session)
iTwt     = input("0900-1659", "Horario final para zerar carteira", type=input.session)


dummyJanela  = input(false, "-----------------------------------------------------------------------", type = input.bool )
iTtz   = syminfo.timezone // input("GMT-3", "What is the Time Zone")
iTdate = input(20200101, " Data inicial para backtest: YYYYMMDD")
iTdias = input(365, "Dias apos a data inicial em backtest")


// Fix Tick on especial assets
iFixMinTick = input(0.0, "Ajusta o tick no Tradingview", minval=0.0, type=input.float)
plotGraphMultiplier = input(4, "Graph Zoom")


// === DEPENDENCE AND FUNCTIONS ===

// GLOBAL VARIABLE
float daily_open = na
daily_open := dayofmonth != dayofmonth[1]? open: daily_open[1]

 


getNum(n, d) =>
    r = floor((n % pow(10, d)) / pow(10, d-1))

// === ESTRATEGIAS ===
// ---------------------------------------------------------------------------------------------------------------------------------
// MEDIA MOVEL
// ---------------------------------------------------------------------------------------------------------------------------------
var mmEntrada = (iMMModo == 1 or iMMModo >= 3)
var mmSaida   = iMMModo > 1
var mmCurta   = float(na)
var mmLonga   = float(na)
if iMMModo 
	mmCurta := iMMCurtaTipo == "Simples"? sma(iMMCurtaSrc[iMMCurtaDes], iMMCurtaLen): ema(iMMCurtaSrc[iMMCurtaDes], iMMCurtaLen)
	mmLonga := iMMLongaTipo == "Simples"? sma(iMMLongaSrc[iMMLongaDes], iMMLongaLen): ema(iMMLongaSrc[iMMLongaDes], iMMLongaLen)

plot(iMMPlot and iMMModo ? mmCurta : na, "MM Curta", #90CAF9, 1, plot.style_line, 0, 15)
plot(iMMPlot and iMMModo ? mmLonga : na, "MM Longa", #9575CD, 2, plot.style_line, 0, 15)
plot(iMMPlot and iMMModo and cross(mmCurta, mmLonga)? avg(mmCurta, mmLonga): na, "MM CRoss", color.black, 2, plot.style_cross, 0, 15)

eMM() =>
	r = 0
	if iMMModo == 0
	    r := 0
	else if iMMForma == "Cruzamento das Medias"
		if  crossover(mmCurta, mmLonga)//mmCurta >= mmLonga and mmCurta[1] < mmLonga[1]
			r := 1
		else if crossunder(mmCurta, mmLonga)//mmCurta <= mmLonga and mmCurta[1] > mmLonga[1]
			r := -1
	else if iMMForma == "Media curta acima/abaixo da longa"
		if mmCurta >= mmLonga
			r := 1
		else if mmCurta <= mmLonga
			r := -1
			
	if iMMInv
	    r := r == 1? -1: r == -1? 1: r
	r

// ---------------------------------------------------------------------------------------------------------------------------------
// HI-LO
// ---------------------------------------------------------------------------------------------------------------------------------
hlEntrada = (iHLModo == 1 or iHLModo >= 3)
hlSaida   = iHLModo > 1
hlHigh    = 0.0
hlLow     = 0.0
hlH       = 0.0
hlL       = 0.0
hlSentido = 0.0
hlPlot    = float(na)
hlColor   = color.white

if iHLModo
	hlHigh := sma(high, iHLLen)
	hlLow  := sma(low, iHLLen)
	hlSentido := close > hlHigh[iHLDist]? 1: close < hlLow[iHLDist]? -1: nz(hlSentido[1])

	hlH := highest(close, iHLLen)
	hlL := lowest(close, iHLLen)
	
	hlPlot  := hlSentido == 1? hlL: hlH
	hlColor := hlSentido != hlSentido[1]? hlColor: hlSentido == 1 ? color.green: hlSentido == -1? color.red: color.yellow
plot(iHLPlot and iHLModo ? hlPlot: na, "Hi Lo Activator", hlColor, 2, plot.style_line, 0, 50)

eHiLo() =>
	r = 0
	if iHLModo == 0
	    r := 0
	else if iHLForma == "Sentido da escada do HiLo"
		if hlSentido == 1
			r := 1
		else if hlSentido == -1
			r := -1
	else if iHLForma == "Mudanca no sentido da escada do HiLo"
		if hlSentido == 1 and hlSentido[1] == -1 // crossover(close, hlHigh[iHLDist])
			r := 1
		else if hlSentido == -1 and hlSentido[1] == 1 // crossunder(close, hlHigh[iHLDist]) //hlSentido == -1 and hlSentido[1] == 1
			r := -1
	if iHLInv
	    r := r == 1? -1: r == -1? 1: r
	r

// ---------------------------------------------------------------------------------------------------------------------------------
// MACD
// ---------------------------------------------------------------------------------------------------------------------------------
macdEntrada = (iMACDModo == 1 or iMACDModo >= 3)
macdSaida   = iMACDModo > 1
var macdTipo = iMACDTipo == "Simples" 
var macdLine = float(na)
var signalLine = float(na)
if iMACDModo
    macdLonga   = ema(iMACDSrc, iMACDLonga) // slow 
    macdCurta   = ema(iMACDSrc, iMACDCurta) // fast
    
    
    macdLine   := macdCurta - macdLonga
    signalLine := macdTipo ? sma(macdLine, iMACDSinal): ema(macdLine, iMACDSinal)

plot(iMACDPlot ? daily_open + macdLine * plotGraphMultiplier : na, "Linha MACD", color.blue)
plot(iMACDPlot ? daily_open + signalLine * plotGraphMultiplier : na, "Sinal MACD", color.red)
plot(iMACDPlot and cross(macdLine, signalLine)? daily_open + avg(macdLine, signalLine) * plotGraphMultiplier: na, "MACD CRoss", color.black, 2, plot.style_cross, 0, 15)

eMACD() =>
	r = 0
	if iMACDModo == 0
	    r := 0
	else if iMACDForma == "Cruzamento da linha MACD com a linha de sinal"
		if crossover(macdLine, signalLine)//macdLine > signalLine and macdLine[1] <= signalLine[1] 
			r :=  1
		else if crossunder(macdLine, signalLine) //macdLine < signalLine and macdLine[1] >= signalLine[1] 
			r := -1
	else if iMACDForma == "Linha MACD acima/abaixo da linha de sinal"
		if signalLine > macdLine 
			r := 1
		else if signalLine < macdLine
			r := -1
	
	if iMACDInv
	    r := r == 1? -1: r == -1? 1: r
	
	if iMACDFiltro
		if r == 1 and macdLine < iMACDFilVal
			r := 0
		else if r == -1 and macdLine > iMACDFilVal
			r := 0
	r
	
// ---------------------------------------------------------------------------------------------------------------------------------
// ADX DI+ /  DI-
// ---------------------------------------------------------------------------------------------------------------------------------
adxEntrada = (iADXModo == 1 or iADXModo >= 3)
adxSaida   = iADXModo > 1
adxUp = 0.0
adxDown = 0.0
adxPlusDM = 0.0
adxMinusDM = 0.0
adxTrur = 0.0
adxPlus = float(na)
adxMinus = float(na)
adxSum = 0.0
adxLine = float(na)
if iADXModo
	adxUp := change(high)
	adxDown := -change(low)
	adxPlusDM := na(adxUp) ? na : (adxUp > adxDown and adxUp > 0 ? adxUp : 0)
	adxMinusDM := na(adxDown) ? na : (adxDown > adxUp and adxDown > 0 ? adxDown : 0)
	adxTrur := rma(tr, iADXLen)
	adxPlus  := fixnan(100 * rma(adxPlusDM, iADXLen) / adxTrur)
	adxMinus := fixnan(100 * rma(adxMinusDM, iADXLen) / adxTrur)
	//adxSum := adxPlus + adxMinus
	//adxLine := (100 * rma(abs(adxPlus - adxMinus) / (adxSum == 0 ? 1 : adxSum), iADXSuave))
	adxSum := adxPlus + adxMinus
	//adxLine := rma(abs(adxPlus - adxMinus) / (adxSum == 0 ? 1 : adxSum), iADXSuave)
	//adxLine := sma(adxSum, iADXSuave) 
	DX = abs(adxPlus-adxMinus) / max(adxSum,1) * 100
    adxLine := rma(DX, iADXSuave)
	
plot(iADXPlot ? daily_open + adxPlus  * plotGraphMultiplier * 10 : na,"DI+", color.blue)
plot(iADXPlot ? daily_open + adxMinus * plotGraphMultiplier * 10 : na,"DI-", color.orange)
plot(iADXPlot ? daily_open + adxLine  * plotGraphMultiplier * 10 : na,"ADX", color.red, linewidth=2)

eADX() =>
	r = 0
	if iADXModo != 0
    	if iADXForma == "Cruzamento do DI+ com o DI-"
    		if crossover(adxPlus, adxMinus) //adxPlus > adxMinus and adxPlus[1] <= adxMinus[1]//crossover(adxPlus, adxMinus)
    			r := 1
    		else if crossunder(adxPlus, adxMinus) //adxPlus < adxMinus and adxPlus[1] >= adxMinus[1] //crossover(adxMinus, adxPlus)
    			r := -1
    	else if iADXForma == "DI+ acima/abaixo do DI-"
    		if adxPlus > adxMinus
    			r := 1
    		else if adxPlus < adxMinus 
    			r := -1
    	if iADXInv
            r := r == 1? -1: r == -1? 1: r
	r
eADXLine() =>
	r = 0
	if iADXModo != 0
    	if adxLine >= iADXMin and adxLine <= iADXMax
    		r := 1
    	if iADXTrend > 0 and adxLine <= adxLine[1]
    		r := 0
    	else if iADXTrend < 0 and adxLine >= adxLine[1]
    		r := 0
	r

// ---------------------------------------------------------------------------------------------------------------------------------
// ESTOCASTICO
// ---------------------------------------------------------------------------------------------------------------------------------
estEntrada = (iESTModo == 1 or iESTModo >= 3)
estSaida   = iESTModo > 1
estK = float(na)
estD = float(na)
if iESTModo
	estK := sma(stoch(close, high, low, iESTLen), iESTSuavK)
	//estK := sma(100 * (close - lowest(low, iESTLen)) / (highest(high, iESTLen) - lowest(low, iESTLen)), iESTSuavK)
    estD := sma(estK, iESTSuavD)

p = plot(iESTPlot and iESTModo ? daily_open + estK * plotGraphMultiplier: na, "K%", color.blue)
plot(iESTPlot and iESTModo     ? daily_open + estD * plotGraphMultiplier: na, "D%", color.red )
plot(iESTPlot and iESTModo and cross(estK, estD) ? daily_open + avg(estK, estD) * plotGraphMultiplier: na, "Stoch Cross", color.black, 2, plot.style_cross, 0, 15)

pestMin = plot(iESTPlot and iESTModo and iESTMin > 0  ? daily_open + iESTMin * plotGraphMultiplier: na)
pestMax = plot(iESTPlot and iESTModo and iESTMax < 100? daily_open + iESTMax * plotGraphMultiplier: na)
fill(pestMax, pestMin)

//if(iESTPlot and iESTModo and cross(estK, estD))
    //label.new(bar_index, na, tostring(estK), color=color.green, textcolor=color.white, style=label.style_labeldown, yloc=yloc.abovebar)


eEST() =>
	r = 0
	if iESTModo == 0
	    r := 0
	else if iESTForma == "Cruzamento da linha %K suavizada com a linha %D suavizada"
		if  estK > estD and estK[1] <= estD[1] // crossover(estK, estD) // estK > estD and estK[1] <= estD[1] 
			r := 1
		else if estK < estD and estK[1] >= estD[1] //crossunder(estK, estD) //estK < estD and estK[1] >= estD[1]
			r := -1
	else if iESTForma == "Linha %K suavizada acima/abaixo da linha %D suavizada"
		if estK > estD
			r := 1
		else if estK < estD
			r := -1

	if iESTInv
	    r := r == 1? -1: r == -1? 1: r

	if (iESTMin > 0 and estK > iESTMin and estK < iESTMax) 
		r := 0
	else if (iESTMax < 100 and estK < iESTMax and estK > iESTMin)
		r := 0
	else if (r == 1 and iESTMax < 100 and estK > iESTMax )
		r := 0
	else if (r == -1 and iESTMin > 0 and estK < iESTMin) 
		r := 0
	
	r


// ---------------------------------------------------------------------------------------------------------------------------------
// VWAP
// ---------------------------------------------------------------------------------------------------------------------------------
vwEntrada = (iVWAPModo == 1 or iVWAPModo >= 3)
vwSaida   = iVWAPModo > 1
plot(iVWAPPlot and iVWAPModo ? vwap : na, "VWAP", #9E9E9E, 3, plot.style_line, 0, 15)

eVWAP() =>
	r = 0
	if iVWAPModo == 0
	    r := 0
	else if iVWAPForma == "Rompimento do VWAP"
		if  crossover(close, vwap) //close > vwap and close[1] <= vwap[1] // crossover(close, vwap)
			r := 1
		else if crossunder(close, vwap) //if close < vwap and close[1] >= vwap[1]  //crossunder(close, vwap)
			r := -1
	else if iVWAPForma == "Compra acima do VWAP / Vende abaixo do VWAP"
		if close > vwap
			r := 1
		else if close < vwap
			r := -1
	else if iVWAPForma == "Vende acima do VWAP / Compra abaixo do VWAP"
		if close > vwap
			r := -1
		else if close < vwap
			r := 1
	if iVWAPInv
        r := r == 1? -1: r == -1? 1: r
	r


// ---------------------------------------------------------------------------------------------------------------------------------
// IFR
// ---------------------------------------------------------------------------------------------------------------------------------
ifrEntrada = (iIFRModo == 1 or iIFRModo >= 3)
ifrSaida   = iIFRModo > 1
ifrUp   = 0.0
ifrDown = 0.0
ifr     = 0.0
if iIFRModo
	ifrUp   := rma(max(change(iIFRSrc), 0), iIFRLen)
	ifrDown := rma(-min(change(iIFRSrc), 0), iIFRLen)
	ifr     := ifrDown == 0 ? 100 : ifrUp == 0 ? 0 : 100 - (100 / (1 + ifrUp / ifrDown))
	
plot(iIFRModo and iIFRPlot ? daily_open + iIFRMax * plotGraphMultiplier : na, "IFR UP",   color.green)
plot(iIFRModo and iIFRPlot ? daily_open + iIFRMin * plotGraphMultiplier : na, "IFR DOWN", color.green)
plot(iIFRModo and iIFRPlot ? daily_open + ifr     * plotGraphMultiplier : na, "IFR",      color.blue, linewidth=2)

pifrMin = plot(iIFRModo and iIFRPlot ? daily_open + iIFRMin  * plotGraphMultiplier: na)
pifrMax = plot(iIFRModo and iIFRPlot ? daily_open + iIFRMax  * plotGraphMultiplier: na)
fill(pifrMax, pifrMin)

eIFR() => 
	r = 0
	if iIFRModo == 0
	    r := 0
	else if iIFRForma == "Cruzamento do IFR com os niveis"
		if crossover(ifr, iIFRMin) //ifr > iIFRMax and ifr[1] <= iIFRMax[1] // crossover(ifr, iIFRMin)
			r := 1
		else if crossunder(ifr, iIFRMax) //ifr < iIFRMin and ifr[1] >= iIFRMin[1] //crossunder(ifr, iIFRMax)
			r := -1
	else if iIFRForma == "IFR acima/abaixo dos niveis sobrecomprado/sobrevendido"
		if ifr > iIFRMax
			r := -1
		else if ifr < iIFRMin
			r := 1
	if iIFRInv
	    r := r == 1? -1: r == -1? 1: r
	r


// ---------------------------------------------------------------------------------------------------------------------------------
// BANDA DE BOLLINGER
// ---------------------------------------------------------------------------------------------------------------------------------
bbEntrada = (iBBModo == 1 or iBBModo >= 3)
bbSaida   = iBBModo > 1
bbBase    = 0.0
bbDesvio  = 0.0
bbUp      = 0.0
bbDown    = 0.0
if iBBModo
	bbBase   := sma(iBBSrc, iBBLen)
	bbDesvio := iBBDes * stdev(iBBSrc, iBBLen) 
	bbUp     := bbBase + bbDesvio
	bbDown   := bbBase - bbDesvio
	
//plot(iBBPlot and iBBModo? bbBase: na, "BB Media base" , #fb8c00, 1, plot.style_circles, 0, 15)
iBBUp   = plot(iBBPlot and iBBModo? bbUp   : na, "BB Up Line"    , color.fuchsia, 1, plot.style_line   , 0, 15)
iBBDown = plot(iBBPlot and iBBModo? bbDown : na, "BB Bottom Line", color.fuchsia, 1, plot.style_line   , 0, 15)
fill(iBBUp, iBBDown, color.fuchsia)

eBB() =>
	r = 0
	if iBBModo == 0
	    r := 0
	else if iBBForma == "Cruzamento do preco com as bandas"
		if crossover(iBBSrc, bbDown) //iBBSrc > bbDown and iBBSrc[1] <= bbDown[1] // crossover(iBBSrc, bbDown)
			r := 1
		else if crossunder(iBBSrc, bbUp) //iBBSrc < bbUp and iBBSrc[1] >= bbUp[1] // crossunder(iBBSrc, bbUp)
			r := -1
	else if iBBForma == "Preco acima/abaixo das bandas"
		if iBBSrc > bbUp
			r := -1
		else if iBBSrc < bbDown 
			r := 1
	if iBBInv
	    r := r == 1? -1: r == -1? 1: r
	r

// ---------------------------------------------------------------------------------------------------------------------------------
// ATOP ATR
// ---------------------------------------------------------------------------------------------------------------------------------
atrEntrada = (iATRModo == 1 or iATRModo >= 3)
atrSaida   = iATRModo > 1
atrX     = float(na)
atrLoss  = float(na)
atrStop  = float(na)
atrPos   = float(na)
atrColor = color.black
if iATRModo
	atrX     := atr(iATRLen)
	atrLoss  := iATRMult * atrX
	atrStop  := iff(open > nz(atrStop[1], 0) and open[1] > nz(atrStop[1], 0), max(nz(atrStop[1]), open - atrLoss), iff(open < nz(atrStop[1], 0) and open[1] < nz(atrStop[1], 0), min(nz(atrStop[1]), open + atrLoss), iff(open > nz(atrStop[1], 0), open - atrLoss, open + atrLoss)))
	atrPos   := iff(open[1] < nz(atrStop[1], 0) and open > nz(atrStop[1], 0), 1, iff(open[1] > nz(atrStop[1], 0) and open < nz(atrStop[1], 0), -1, nz(atrPos[1], 0)))
	atrColor := atrPos == -1 ? color.red: atrPos == 1 ? color.blue : color.green
	
plot(iATRPlot and iATRModo? atrStop: na, "Stop ATR", atrColor, 1, plot.style_line, 0, 15) 

eATR() =>
	r = 0
	if iATRModo == 0
	    r := 0
	else if iATRForma == "Mudanca no sentido do Stop ATR"
		if crossover(close, atrStop) //close > atrStop and close[1] <= atrStop[1] // crossover(close, atrStop)
			r := 1 
		else if crossunder(close, atrStop) //close < atrStop and close[1] >= atrStop[1] //crossunder(close, atrStop)
			r := -1
	else if iATRForma == "Sentido do Stop ATR"
		if close > atrStop //and atrStop > atrStop[1]
			r := 1
		else if close < atrStop //and atrStop < atrStop[1]
			r := -1
    if iATRInv
	    r := r == 1? -1: r == -1? 1: r
	r

// ---------------------------------------------------------------------------------------------------------------------------------
// SAR
// ---------------------------------------------------------------------------------------------------------------------------------
sarEntrada = (iSARModo == 1 or iSARModo >= 3)
sarSaida   = iSARModo > 1
sarVal   = 0.0
sarColor = color.black
if iSARModo
	sarVal   := sar(iSARFA, iSARFI, iSARLim)
	sarColor := iff(close > sarVal, #4dd0e1, #f06292)

plot(iSARPlot and iSARModo? sarVal: na, "Parabolic SAR", sarColor, 2, plot.style_circles, 0, 15)

eSAR() =>
	r = 0
	if iSARModo == 0
	    r := 0
	else if iSARForma == "Mudanca no sentido dos pontos do SAR"
		if  crossover(close, sarVal) //close > sarVal and close[1] <= sarVal[1] //crossover(close, sarVal)
			r := 1
		else if crossunder(close, sarVal) // close < sarVal and close[1] >= sarVal[1] //crossunder(close, sarVal)
			r := -1
	else if iSARForma == "Sentido dos pontos do SAR"
		if close > sarVal
			r := 1
		else if close < sarVal
			r := -1
    if iSARInv
	    r := r == 1? -1: r == -1? 1: r
	r


// ---------------------------------------------------------------------------------------------------------------------------------
// === MANEJO DE DAY TRADE ===
// ---------------------------------------------------------------------------------------------------------------------------------
var cumulativeLastDayNetProfit = 0.0
var intradayProfit = 0.0
var cumulativeLastDayFilledOrders = 0
var intradayFilledOrder = 0
var cumulativeLastDayLostdOrders = 0
var intradayLostOrder = 0
var dayStop = false

if dayofmonth[1] != dayofmonth
	cumulativeLastDayNetProfit    := strategy.netprofit
	cumulativeLastDayFilledOrders := strategy.losstrades + strategy.wintrades
	cumulativeLastDayLostdOrders  := strategy.losstrades
	intradayFilledOrder           := 0
	intradayLostOrder             := 0
    intradayProfit                := 0
    dayStop                       := false

intradayFilledOrder := strategy.losstrades + strategy.wintrades  - cumulativeLastDayFilledOrders + strategy.opentrades 
intradayLostOrder   := strategy.losstrades - cumulativeLastDayLostdOrders 
intradayProfit      := strategy.netprofit  + strategy.openprofit - cumulativeLastDayNetProfit   

if not dayStop
    dayStop :=            intradayProfit      >= iSDGanho 
    dayStop := dayStop or intradayProfit      <= -iSDPerda 
    dayStop := dayStop or intradayLostOrder   >= iSDXTradesLost  
    dayStop := dayStop or intradayFilledOrder >= iSDXTrades


// === DAY TRADE TIME RESTRICTION ===
// you can put fixed values and comment the input to have a cleanner menu.
wy = getNum(iTdate, 8) * 1000 + getNum(iTdate, 7) * 100 + getNum(iTdate, 6) * 10 + getNum(iTdate, 5)
wm = getNum(iTdate, 4) * 10   + getNum(iTdate, 3)
wd = getNum(iTdate, 2) * 10   + getNum(iTdate, 1)

wot =   time('1', iTot)
wwt =   time('1', iTwt)
wjan1 = time('1', iJanela1)
wjan2 = time('1', iJanela2)

woti = timestamp(iTtz, wy, wm, wd, 0, 0)
wotf = woti + (iTdias * 86400000)
inRangeToProcesBt = time >= woti and time <= wotf

bool allowedToEnterOrder = time(timeframe.period, iTot) 
allowedToEnterOrder     := allowedToEnterOrder and not dayStop 
allowedToEnterOrder     := allowedToEnterOrder and inRangeToProcesBt 
allowedToEnterOrder     := allowedToEnterOrder and not wjan1 and not wjan2

bool workTimeWindow  = time(timeframe.period, iTwt)
workTimeWindow      := workTimeWindow and not dayStop

// bgcolor(workTimeWindow ? na: #FFFFFF, transp=80)
bgcolor(allowedToEnterOrder ? color.white: workTimeWindow ? color.yellow: color.orange, transp=80)

// === STRATEGY FUNCTIONS ===

// === SERIES SETUP  GENERAL ===
minTick  = iFixMinTick ? iFixMinTick: syminfo.mintick

// === RISK MANAGEMENT VALUE PREP ===
// if an input is less than 1, assuming not wanted so we assign 'na' value to disable it.
eStop = iEStopFixo    > 0 ? iEStopFixo    / minTick: na
eTake = iETakeFixo    > 0 ? iETakeFixo    / minTick: na
eTS   = iETSAtivar    > 0 ? iETSAtivar    / minTick: na
eTSD  = iETSDistancia > 0 ? iETSDistancia / minTick: na
eParc = iEParcialT    > 0 ? iEParcialT    / minTick: na

cEntradas() =>
	ce = ""
	ce := ce + (mmEntrada   ? "A" : na)
	ce := ce + (hlEntrada   ? "B" : na)
	ce := ce + (macdEntrada ? "C" : na)
	ce := ce + (adxEntrada  ? "D" : na)
	ce := ce + (estEntrada  ? "E" : na)
	ce := ce + (vwEntrada   ? "F" : na)
	ce := ce + (ifrEntrada  ? "G" : na)
	ce := ce + (bbEntrada   ? "H" : na)
	ce := ce + (atrEntrada  ? "I" : na)
	ce := ce + (sarEntrada  ? "J" : na)
	ce

cSaidas() =>
	cs = ""
	cs := cs + (mmSaida   ? "A" : na)
	cs := cs + (hlSaida   ? "B" : na)
	cs := cs + (macdSaida ? "C" : na)
	cs := cs + (adxSaida  ? "D" : na)
	cs := cs + (estSaida  ? "E" : na)
	cs := cs + (vwSaida   ? "F" : na)
	cs := cs + (ifrSaida  ? "G" : na)
	cs := cs + (bbSaida   ? "H" : na)
	cs := cs + (atrSaida  ? "I" : na)
	cs := cs + (sarSaida  ? "J" : na)
	cs
	
//long
var indicadoresCompra = string(na)
indicadoresCompra :=                     (mmEntrada   and eMM()   > 0? "A" : na)
indicadoresCompra := indicadoresCompra + (hlEntrada   and eHiLo() > 0? "B" : na)
indicadoresCompra := indicadoresCompra + (macdEntrada and eMACD() > 0? "C" : na)
indicadoresCompra := indicadoresCompra + (adxEntrada  and eADX()  > 0 and eADXLine() > 0? "D": na)
indicadoresCompra := indicadoresCompra + (estEntrada  and eEST()  > 0? "E" : na)
indicadoresCompra := indicadoresCompra + (vwEntrada   and eVWAP() > 0? "F" : na)
indicadoresCompra := indicadoresCompra + (ifrEntrada  and eIFR()  > 0? "G" : na)
indicadoresCompra := indicadoresCompra + (bbEntrada   and eBB()   > 0? "H" : na)
indicadoresCompra := indicadoresCompra + (atrEntrada  and eATR()  > 0? "I" : na)
indicadoresCompra := indicadoresCompra + (sarEntrada  and eSAR()  > 0? "J" : na)

entradaCompra() =>
	compra = indicadoresCompra != na and indicadoresCompra == cEntradas()
    //compra := compra and not (iPrevinir and indicadoresCompra[1] == indicadoresCompra)
	compra := compra and allowedToEnterOrder
	compra := compra and barstate.isconfirmed 
	compra := compra and ((iOPModo == 4 and strategy.position_size <= 0) or ((iOPModo == 3 or iOPModo == 1) and strategy.position_size == 0))    
	compra := compra and (not iPrevinir or (indicadoresCompra[1] != indicadoresCompra or intradayFilledOrder == 0))
	compra

	
//short
var indicadoresVenda = string(na)
indicadoresVenda :=                    (mmEntrada   and eMM()   < 0? "A" : na)
indicadoresVenda := indicadoresVenda + (hlEntrada   and eHiLo() < 0? "B" : na)
indicadoresVenda := indicadoresVenda + (macdEntrada and eMACD() < 0? "C" : na)
indicadoresVenda := indicadoresVenda + (adxEntrada  and eADX()  < 0 and eADXLine() > 0 ? "D": na)
indicadoresVenda := indicadoresVenda + (estEntrada  and eEST()  < 0? "E" : na)
indicadoresVenda := indicadoresVenda + (vwEntrada   and eVWAP() < 0? "F" : na)
indicadoresVenda := indicadoresVenda + (ifrEntrada  and eIFR()  < 0? "G" : na)
indicadoresVenda := indicadoresVenda + (bbEntrada   and eBB()   < 0? "H" : na)
indicadoresVenda := indicadoresVenda + (atrEntrada  and eATR()  < 0? "I" : na)
indicadoresVenda := indicadoresVenda + (sarEntrada  and eSAR()  < 0? "J" : na)


entradaVenda() =>
	venda = indicadoresVenda != na and indicadoresVenda == cEntradas()
	venda := venda and allowedToEnterOrder
	venda := venda and barstate.isconfirmed
	venda := venda and ((iOPModo == 4 and strategy.position_size >= 0) or ((iOPModo == 2 or iOPModo == 3) and strategy.position_size == 0))
    venda := venda and (not iPrevinir or (indicadoresVenda[1] != indicadoresVenda or intradayFilledOrder == 0))
	venda

//if entradaVenda()
//    label.new(bar_index, na, indicadoresVenda[1] + " / " + indicadoresVenda, color=color.green, textcolor=color.white, style=label.style_labeldown, yloc=yloc.abovebar)

//long
saidaCompra() =>
	sc =       (mmSaida   and eMM()   < 0? "A" : na) 
	sc := sc + (hlSaida   and eHiLo() < 0? "B" : na)
	sc := sc + (macdSaida and eMACD() < 0? "C" : na)
	sc := sc + (adxSaida  and eADX()  < 0? "D" : na)
	sc := sc + (estSaida  and eEST()  < 0? "E" : na)
	sc := sc + (vwSaida   and eVWAP() < 0? "F" : na)
	sc := sc + (ifrSaida  and eIFR()  < 0? "G" : na)
	sc := sc + (bbSaida   and eBB()   < 0? "H" : na) 
	sc := sc + (atrSaida  and eATR()  < 0? "I" : na)
	sc := sc + (sarSaida  and eSAR()  < 0? "J" : na)
	compra = strategy.position_size > 0
	compra := compra and sc != na
	compra := compra and (not iSaidaAll or sc == cSaidas()) 
	compra := compra and barstate.isconfirmed
	compra
	

// short
saidaVenda() =>
	sv =       (mmSaida   and eMM()   > 0? "A" : na) 
	sv := sv + (hlSaida   and eHiLo() > 0? "B" : na)
	sv := sv + (macdSaida and eMACD() > 0? "C" : na)
	sv := sv + (adxSaida  and eADX()  > 0? "D" : na)
	sv := sv + (estSaida  and eEST()  > 0? "E" : na)
	sv := sv + (vwSaida   and eVWAP() > 0? "F" : na)
	sv := sv + (ifrSaida  and eIFR()  > 0? "G" : na)
	sv := sv + (bbSaida   and eBB()   > 0? "H" : na)
	sv := sv + (atrSaida  and eATR()  > 0? "I" : na)
	sv := sv + (sarSaida  and eSAR()  > 0? "J" : na)
	venda = strategy.position_size < 0
	venda := venda and sv != na 
	venda := venda and (not iSaidaAll or sv == cSaidas()) 
	venda := venda and barstate.isconfirmed
	venda

// === MARTIGALE =========
float initialOrderAmount = na
var martigaleOrderMultiplier = 1

if nz(initialOrderAmount) == 0  and strategy.position_size != 0
    initialOrderAmount := abs(strategy.position_size)

var lossTrades = 0
var wintrades = 0
if iEMartingale > 0
    if (entradaCompra() or entradaVenda())         
        if lossTrades < strategy.losstrades 
            if martigaleOrderMultiplier < pow(2, iEMartingale) 
                martigaleOrderMultiplier := martigaleOrderMultiplier * 2
            else 
                martigaleOrderMultiplier := 1
            lossTrades := strategy.losstrades
            
        if (wintrades < strategy.wintrades) 
            martigaleOrderMultiplier := 1
            wintrades := strategy.wintrades


// === STRATEGY ===
openProfit = "$ " + tostring (strategy.openprofit)
ordersToBuy = initialOrderAmount * martigaleOrderMultiplier
ordersToRevert = initialOrderAmount * 1 + (initialOrderAmount * martigaleOrderMultiplier)

eCompra = entradaCompra()
eVenda = entradaVenda()
//label.new(bar_index, na, indicadoresVenda[1] + " / " + indicadoresVenda, color=color.green, textcolor=color.white, style=label.style_labeldown, yloc=yloc.abovebar)
//label.new(bar_index, na, (eCompra?"true":"false") +" / "+ (eVenda?"true":"false"), color=color.green, textcolor=color.white, style=label.style_labeldown, yloc=yloc.abovebar)
strategy.entry("Compra", strategy.long, qty=ordersToBuy, when = eCompra and strategy.position_size == 0, comment = "EC")
strategy.entry("Venda", strategy.short, qty=ordersToBuy, when = eVenda  and strategy.position_size == 0, comment = "EV")

strategy.order("Compra", strategy.long, qty=ordersToRevert, when = eCompra and strategy.position_size != 0, comment = "RC " + openProfit)
strategy.order("Venda", strategy.short, qty=ordersToRevert, when = eVenda  and strategy.position_size != 0, comment = "RV " + openProfit)

sCompra = saidaCompra() and not eCompra and not eVenda
sVenda  = saidaVenda()  and not eCompra and not eVenda
strategy.close("Compra", when=sCompra, comment = "SC " + openProfit)
strategy.close("Venda" , when=sVenda , comment = "SV " + openProfit)

// -----------------------------------------------------------------------------------------

minNonZero(v1, v2)=>
    nz(v1)>0 and nz(v2)>0? min(v1, v2) :max(v1, v2)

globalLoss = (abs(intradayProfit + strategy.openprofit + iSDPerda) / syminfo.pointvalue) / minTick
globalGain = (abs(intradayProfit + strategy.openprofit - iSDGanho) / syminfo.pointvalue) / minTick

tradeLoss = eStop==0 and iEParcialBE ? eParc: eStop
tradeLoss := minNonZero(tradeLoss, globalLoss)
tradeTake = minNonZero(eTake, globalGain)

if eParc > 0 and eParc < tradeTake and abs(strategy.position_size) >= initialOrderAmount 
    strategy.exit("SaidaParcial", qty_percent=50, profit=eParc, trail_points=eTS, trail_offset=eTSD, loss=eStop, comment = "Saida Take Parcial")
else
    //l = label.new(bar_index, na, tostring(tradeTake) + " / " + tostring(tradeLoss), color=color.green, textcolor=color.white, style=label.style_labeldown, yloc=yloc.abovebar)
    strategy.exit("Saida",  profit=tradeTake, trail_points=eTS, trail_offset=eTSD, loss=tradeLoss, comment = "Saida Take/Loss " + tostring(tradeTake) + "/" + tostring(tradeLoss * minTick))
    
getOut = not workTimeWindow
strategy.cancel_all(getOut)
strategy.close_all(getOut, comment = "Close ALL")

strategy.risk.max_intraday_loss(iSDPerda, strategy.cash)
strategy.risk.max_intraday_filled_orders(iSDXTrades * 2)
